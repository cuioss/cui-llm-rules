= JavaScript Best Practices Standards
:toc: left
:toclevels: 3
:sectnums:

== Purpose
Defines comprehensive standards for modern JavaScript development patterns, conventions, and best practices for CUI projects using ES2022+ features without TypeScript.

== Related Documentation
* xref:linting-standards.adoc[Linting Standards]: ESLint rules that enforce these practices
* xref:lit-components-standards.adoc[Lit Components Standards]: Component-specific patterns
* xref:unit-testing-standards.adoc[Unit Testing Standards]: Testing modern JavaScript patterns

== Modern JavaScript Standards

=== ECMAScript Version Support
* **Target**: ES2022 (ES13) and later features
* **Browser Support**: Modern browsers with native ES modules
* **Node.js**: Version 20.12.2 LTS or later
* **Transpilation**: Babel for test environments only

=== Module System Standards
Use ES modules exclusively:

[source,javascript]
----
// Named exports (preferred)
export const utilityFunction = () => {
  // Implementation
};

export class ComponentClass {
  // Implementation
}

// Default exports (when appropriate)
export default class MainComponent {
  // Implementation
}

// Re-exports
export { SomeClass } from './some-module.js';
export * from './utilities.js';
----

=== Import Patterns
Follow consistent import conventions:

[source,javascript]
----
// Framework imports first
import { html, css, LitElement } from 'lit';

// Third-party imports
import { customElement, property } from 'lit/decorators.js';

// Local imports (relative paths)
import { validateInput } from '../utilities/validation.js';
import { API_ENDPOINTS } from '../config/constants.js';

// Import specific items, avoid wildcard imports
import { debounce, throttle } from '../utilities/performance.js';
----

== Variable and Function Standards

=== Variable Declaration
Use `const` by default, `let` when reassignment is needed:

[source,javascript]
----
// Preferred: const for immutable bindings
const apiEndpoint = 'https://api.example.com';
const userConfig = { timeout: 5000 };

// Use let for reassignment
let currentUser = null;
let retryCount = 0;

// Never use var
// var deprecatedVariable = 'avoid this';
----

=== Function Declaration Patterns
Use arrow functions for most cases, regular functions for methods:

[source,javascript]
----
// Arrow functions for utilities and callbacks
const processData = (data) => {
  return data.map(item => item.value);
};

const handleEvent = (event) => {
  event.preventDefault();
  // Handle event
};

// Regular functions for methods and constructors
class DataProcessor {
  constructor(options) {
    this.options = options;
  }

  processItems(items) {
    return items.filter(item => this.isValid(item));
  }
}

// Async functions
const fetchUserData = async (userId) => {
  try {
    const response = await fetch(`/api/users/${userId}`);
    return await response.json();
  } catch (error) {
    console.error('Failed to fetch user data:', error);
    throw error;
  }
};
----

=== Destructuring Standards
Use destructuring for object and array manipulation:

[source,javascript]
----
// Object destructuring
const { name, email, preferences = {} } = user;
const { theme, language } = preferences;

// Array destructuring
const [first, second, ...rest] = items;

// Function parameter destructuring
const createUser = ({ name, email, role = 'user' }) => {
  return { id: generateId(), name, email, role };
};

// Nested destructuring (when readable)
const { 
  config: { api: { endpoint, timeout } },
  user: { name, permissions }
} = applicationState;
----

=== Template Literals
Use template literals for string interpolation:

[source,javascript]
----
// String interpolation
const message = `Hello, ${user.name}! You have ${messageCount} messages.`;

// Multi-line strings
const htmlTemplate = `
  <div class="user-card">
    <h2>${user.name}</h2>
    <p>${user.email}</p>
  </div>
`;

// Complex expressions
const apiUrl = `${baseUrl}/api/v${apiVersion}/users/${userId}?include=${includes.join(',')}`;
----

== Object and Array Standards

=== Object Creation and Manipulation
Use modern object syntax and methods:

[source,javascript]
----
// Object shorthand properties
const createConfig = (endpoint, timeout, retries) => ({
  endpoint,
  timeout,
  retries,
  timestamp: Date.now(),
});

// Computed property names
const createDynamicObject = (key, value) => ({
  [key]: value,
  [`${key}Processed`]: processValue(value),
});

// Object spread for immutable updates
const updateUser = (user, updates) => ({
  ...user,
  ...updates,
  lastModified: Date.now(),
});

// Object.entries for iteration
const processConfig = (config) => {
  Object.entries(config).forEach(([key, value]) => {
    console.log(`${key}: ${value}`);
  });
};
----

=== Array Methods and Patterns
Use functional array methods:

[source,javascript]
----
// Transformation
const processedItems = items
  .filter(item => item.isActive)
  .map(item => ({
    ...item,
    processed: true,
    timestamp: Date.now(),
  }))
  .sort((a, b) => a.priority - b.priority);

// Finding elements
const activeUser = users.find(user => user.status === 'active');
const hasAdminUser = users.some(user => user.role === 'admin');
const allValidated = users.every(user => user.isValidated);

// Aggregation
const totalValue = items.reduce((sum, item) => sum + item.value, 0);

// Grouping (modern approach)
const groupedByCategory = items.reduce((groups, item) => {
  const key = item.category;
  groups[key] = groups[key] || [];
  groups[key].push(item);
  return groups;
}, {});
----

=== Array Spread and Rest
Use spread and rest operators effectively:

[source,javascript]
----
// Array spreading
const mergedItems = [...existingItems, ...newItems];
const clonedArray = [...originalArray];

// Rest parameters
const processItems = (primaryItem, ...additionalItems) => {
  console.log('Processing primary:', primaryItem);
  additionalItems.forEach(item => console.log('Additional:', item));
};

// Array destructuring with rest
const [head, ...tail] = items;
const [first, second, ...remaining] = sortedItems;
----

== Asynchronous Programming Standards

=== Promise and Async/Await Patterns
Use async/await consistently:

[source,javascript]
----
// Async function with proper error handling
const fetchAndProcessData = async (url) => {
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const data = await response.json();
    return processData(data);
  } catch (error) {
    console.error('Failed to fetch and process data:', error);
    throw error; // Re-throw for caller to handle
  }
};

// Concurrent operations
const fetchMultipleResources = async (urls) => {
  try {
    const responses = await Promise.all(
      urls.map(url => fetch(url))
    );
    
    const data = await Promise.all(
      responses.map(response => response.json())
    );
    
    return data;
  } catch (error) {
    console.error('Failed to fetch multiple resources:', error);
    throw error;
  }
};

// Sequential operations when needed
const processItemsSequentially = async (items) => {
  const results = [];
  
  for (const item of items) {
    const result = await processItem(item);
    results.push(result);
  }
  
  return results;
};
----

=== Error Handling Standards
Implement comprehensive error handling:

[source,javascript]
----
// Custom error classes
class ValidationError extends Error {
  constructor(field, value, message) {
    super(message);
    this.name = 'ValidationError';
    this.field = field;
    this.value = value;
  }
}

class NetworkError extends Error {
  constructor(url, status, message) {
    super(message);
    this.name = 'NetworkError';
    this.url = url;
    this.status = status;
  }
}

// Error handling with specific error types
const validateAndSave = async (data) => {
  try {
    validateData(data);
    return await saveData(data);
  } catch (error) {
    if (error instanceof ValidationError) {
      console.warn(`Validation failed for ${error.field}:`, error.message);
      throw error;
    }
    
    if (error instanceof NetworkError) {
      console.error(`Network error (${error.status}):`, error.message);
      // Implement retry logic or fallback
      throw error;
    }
    
    console.error('Unexpected error:', error);
    throw error;
  }
};
----

=== Promise Utilities
Use appropriate Promise utilities:

[source,javascript]
----
// Timeout wrapper
const withTimeout = (promise, timeoutMs) => {
  return Promise.race([
    promise,
    new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Operation timed out')), timeoutMs)
    ),
  ]);
};

// Retry logic
const retryOperation = async (operation, maxRetries = 3, delay = 1000) => {
  let lastError;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error;
      
      if (attempt === maxRetries) {
        throw error;
      }
      
      console.warn(`Attempt ${attempt} failed, retrying in ${delay}ms:`, error.message);
      await new Promise(resolve => setTimeout(resolve, delay));
      delay *= 2; // Exponential backoff
    }
  }
  
  throw lastError;
};
----

== Class and Object-Oriented Patterns

=== Class Definition Standards
Use modern class syntax with proper structure:

[source,javascript]
----
class DataManager {
  // Private fields (when supported)
  #privateData = new Map();
  
  // Static properties
  static DEFAULT_CONFIG = {
    timeout: 5000,
    retries: 3,
  };
  
  constructor(config = {}) {
    this.config = { ...DataManager.DEFAULT_CONFIG, ...config };
    this.cache = new Map();
    this.subscribers = new Set();
  }
  
  // Public methods
  async getData(key) {
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    
    const data = await this.#fetchData(key);
    this.cache.set(key, data);
    return data;
  }
  
  // Private methods
  async #fetchData(key) {
    // Implementation
  }
  
  // Getters and setters
  get size() {
    return this.cache.size;
  }
  
  set maxSize(value) {
    this.#maxSize = Math.max(1, value);
    this.#enforceMaxSize();
  }
  
  // Static methods
  static create(config) {
    return new DataManager(config);
  }
}
----

=== Composition over Inheritance
Favor composition patterns:

[source,javascript]
----
// Mixins for shared behavior
const EventEmitterMixin = (Base) => class extends Base {
  constructor(...args) {
    super(...args);
    this.listeners = new Map();
  }
  
  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event).add(callback);
  }
  
  emit(event, data) {
    const callbacks = this.listeners.get(event);
    if (callbacks) {
      callbacks.forEach(callback => callback(data));
    }
  }
};

// Usage
class Component extends EventEmitterMixin(HTMLElement) {
  connectedCallback() {
    this.emit('connected', { element: this });
  }
}

// Factory functions for object creation
const createApiClient = (baseUrl, options = {}) => {
  const defaultOptions = {
    timeout: 5000,
    retries: 3,
    headers: { 'Content-Type': 'application/json' },
  };
  
  const config = { ...defaultOptions, ...options };
  
  return {
    get: (endpoint) => fetch(`${baseUrl}${endpoint}`, {
      method: 'GET',
      ...config,
    }),
    
    post: (endpoint, data) => fetch(`${baseUrl}${endpoint}`, {
      method: 'POST',
      body: JSON.stringify(data),
      ...config,
    }),
  };
};
----

== Functional Programming Patterns

=== Pure Functions
Write pure functions when possible:

[source,javascript]
----
// Pure functions - no side effects, deterministic
const calculateTax = (amount, rate) => amount * rate;

const formatCurrency = (amount, currency = 'USD') => 
  new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency,
  }).format(amount);

const normalizeText = (text) => 
  text.trim().toLowerCase().replace(/\s+/g, ' ');

// Immutable data transformations
const addItemToCart = (cart, item) => ({
  ...cart,
  items: [...cart.items, item],
  total: cart.total + item.price,
});

const updateItemInList = (list, id, updates) =>
  list.map(item => 
    item.id === id ? { ...item, ...updates } : item
  );
----

=== Higher-Order Functions
Use and create higher-order functions:

[source,javascript]
----
// Function decorators
const withLogging = (fn) => (...args) => {
  console.log(`Calling ${fn.name} with:`, args);
  const result = fn(...args);
  console.log(`${fn.name} returned:`, result);
  return result;
};

const withRetry = (fn, maxRetries = 3) => async (...args) => {
  let lastError;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await fn(...args);
    } catch (error) {
      lastError = error;
      if (attempt === maxRetries) throw error;
    }
  }
};

// Currying and partial application
const createValidator = (schema) => (data) => {
  // Validation logic using schema
  return validateAgainstSchema(data, schema);
};

const userValidator = createValidator(userSchema);
const isValidUser = userValidator(userData);

// Function composition
const pipe = (...functions) => (value) =>
  functions.reduce((acc, fn) => fn(acc), value);

const processUserData = pipe(
  normalizeUserInput,
  validateUserData,
  enrichUserData,
  saveUserData
);
----

=== Utility Functions
Create reusable utility functions:

[source,javascript]
----
// Debounce and throttle
const debounce = (func, delay) => {
  let timeoutId;
  return (...args) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(this, args), delay);
  };
};

const throttle = (func, limit) => {
  let inThrottle;
  return (...args) => {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
};

// Deep clone utility
const deepClone = (obj) => {
  if (obj === null || typeof obj !== 'object') return obj;
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof Array) return obj.map(deepClone);
  
  const cloned = {};
  Object.keys(obj).forEach(key => {
    cloned[key] = deepClone(obj[key]);
  });
  
  return cloned;
};

// Safe property access
const get = (obj, path, defaultValue = undefined) => {
  const keys = path.split('.');
  let result = obj;
  
  for (const key of keys) {
    if (result == null || typeof result !== 'object') {
      return defaultValue;
    }
    result = result[key];
  }
  
  return result !== undefined ? result : defaultValue;
};
----

== Performance and Optimization Standards

=== Memory Management
Implement proper memory management:

[source,javascript]
----
class ComponentManager {
  constructor() {
    this.components = new Map();
    this.eventListeners = new WeakMap();
    this.abortController = new AbortController();
  }
  
  addComponent(id, component) {
    this.components.set(id, component);
    
    // Use AbortController for cleanup
    component.addEventListener('destroy', () => {
      this.removeComponent(id);
    }, { signal: this.abortController.signal });
  }
  
  removeComponent(id) {
    const component = this.components.get(id);
    if (component) {
      // Clean up component resources
      component.destroy?.();
      this.components.delete(id);
    }
  }
  
  destroy() {
    // Clean up all resources
    this.abortController.abort();
    this.components.clear();
  }
}
----

=== Lazy Loading and Code Splitting
Implement lazy loading patterns:

[source,javascript]
----
// Dynamic imports for code splitting
const loadModule = async (moduleName) => {
  try {
    const module = await import(`./modules/${moduleName}.js`);
    return module.default || module;
  } catch (error) {
    console.error(`Failed to load module ${moduleName}:`, error);
    throw error;
  }
};

// Lazy component loading
class LazyComponentLoader {
  constructor() {
    this.loadedComponents = new Map();
  }
  
  async loadComponent(name) {
    if (this.loadedComponents.has(name)) {
      return this.loadedComponents.get(name);
    }
    
    const Component = await loadModule(`components/${name}`);
    this.loadedComponents.set(name, Component);
    return Component;
  }
}

// Intersection Observer for lazy loading
const createLazyLoader = (callback) => {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        callback(entry.target);
        observer.unobserve(entry.target);
      }
    });
  });
  
  return {
    observe: (element) => observer.observe(element),
    disconnect: () => observer.disconnect(),
  };
};
----

=== Caching Strategies
Implement efficient caching:

[source,javascript]
----
class LRUCache {
  constructor(maxSize = 100) {
    this.maxSize = maxSize;
    this.cache = new Map();
  }
  
  get(key) {
    if (this.cache.has(key)) {
      const value = this.cache.get(key);
      // Move to end (most recently used)
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    }
    return undefined;
  }
  
  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      // Remove least recently used
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, value);
  }
}

// Memoization utility
const memoize = (fn, keyGenerator = (...args) => JSON.stringify(args)) => {
  const cache = new Map();
  
  return (...args) => {
    const key = keyGenerator(...args);
    
    if (cache.has(key)) {
      return cache.get(key);
    }
    
    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
};
----

== Code Organization Standards

=== Module Organization
Organize modules logically:

[source,javascript]
----
// utilities/validation.js
export const validateEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

export const validateRequired = (value, fieldName) => {
  if (!value || (typeof value === 'string' && !value.trim())) {
    throw new ValidationError(fieldName, value, `${fieldName} is required`);
  }
};

// config/constants.js
export const API_ENDPOINTS = {
  USERS: '/api/users',
  CONFIG: '/api/config',
  HEALTH: '/api/health',
};

export const HTTP_STATUS = {
  OK: 200,
  CREATED: 201,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  NOT_FOUND: 404,
  INTERNAL_SERVER_ERROR: 500,
};

// services/api.js
import { API_ENDPOINTS } from '../config/constants.js';

export class ApiService {
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
  }
  
  async get(endpoint) {
    // Implementation
  }
}
----

=== Barrel Exports
Use index files for clean imports:

[source,javascript]
----
// utilities/index.js
export * from './validation.js';
export * from './formatting.js';
export * from './performance.js';

// Usage in other files
import { validateEmail, formatCurrency, debounce } from '../utilities/index.js';
----

== Documentation Standards

=== JSDoc Standards
Document all public APIs:

[source,javascript]
----
/**
 * Processes user data with validation and transformation.
 * 
 * @param {Object} userData - The user data to process
 * @param {string} userData.name - User's full name
 * @param {string} userData.email - User's email address
 * @param {Object} [options={}] - Processing options
 * @param {boolean} [options.validateEmail=true] - Whether to validate email
 * @param {boolean} [options.normalize=true] - Whether to normalize data
 * @returns {Promise<Object>} Processed user data
 * @throws {ValidationError} When validation fails
 * 
 * @example
 * ```javascript
 * const user = await processUserData(
 *   { name: 'John Doe', email: 'john@example.com' },
 *   { validateEmail: true }
 * );
 * ```
 */
const processUserData = async (userData, options = {}) => {
  // Implementation
};
----

=== Code Comments
Write meaningful comments:

[source,javascript]
----
// Explain why, not what
class DataProcessor {
  constructor(config) {
    // Use WeakMap to prevent memory leaks when components are destroyed
    this.componentData = new WeakMap();
    
    // Debounce saves to prevent excessive API calls during rapid updates
    this.saveData = debounce(this._saveToServer.bind(this), 1000);
  }
  
  processItems(items) {
    // Filter out items that fail validation to prevent downstream errors
    return items
      .filter(item => this._isValid(item))
      .map(item => {
        // Transform data to match API expectations
        return this._transformForApi(item);
      });
  }
}
----
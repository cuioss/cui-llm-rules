= Cypress E2E Testing Standards
:toc: left
:toclevels: 3
:sectnums:

== Purpose
Defines comprehensive standards for Cypress End-to-End (E2E) testing that extend the base CUI JavaScript standards with framework-specific adaptations for test automation scenarios.

IMPORTANT: These standards are specifically designed for Cypress E2E testing frameworks and extend the base CUI JavaScript standards with test-specific accommodations. They should NOT be applied to general application code.

== Related Documentation
* xref:javascript-development-standards.adoc[JavaScript Development Standards]: Base standards that apply to all JavaScript code
* xref:linting-standards.adoc[Linting Standards]: ESLint configuration adaptations for Cypress
* xref:unit-testing-standards.adoc[Unit Testing Standards]: Jest-based unit testing patterns

== Framework-Specific Adaptations

=== Code Complexity Accommodations
Cypress E2E tests require different complexity thresholds due to the nature of end-to-end test scenarios:

==== Function Length Limits
[source,javascript]
----
// ESLint rule adaptation for Cypress test files
"max-lines-per-function": ["error", {
  "max": 200,           // Increased from 50 for test scenarios
  "skipBlankLines": true,
  "skipComments": true
}]
----

**Rationale**: E2E test scenarios often require longer functions to maintain test cohesion and readability when testing complete user workflows.

==== Cyclomatic Complexity
[source,javascript]
----
// ESLint rule adaptation for Cypress test files
"complexity": ["error", {
  "max": 25  // Increased from 10 for complex test scenarios
}]
----

**Rationale**: E2E tests frequently include multiple conditional paths to handle different application states and user interactions.

=== Complete ESLint Configuration Example

==== Production-Ready Configuration
Based on successful zero-warning implementation achieving 98 warnings → 0 warnings:

[source,javascript]
----
// .eslintrc.js - Complete Cypress configuration
module.exports = {
  env: {
    browser: true,
    es2021: true,
    node: true,
    "cypress/globals": true
  },
  extends: [
    "eslint:recommended",
    "plugin:cypress/recommended",
    "plugin:jsdoc/recommended",
    "plugin:prettier/recommended"
  ],
  parserOptions: {
    ecmaVersion: 2022,
    sourceType: "module"
  },
  plugins: [
    "cypress", 
    "prettier", 
    "jsdoc", 
    "sonarjs", 
    "security",
    "unicorn"
  ],
  rules: {
    // CUI Standards - Fundamental Rules
    "no-console": "warn",
    "no-unused-vars": ["warn", { 
      "argsIgnorePattern": "^_", 
      "varsIgnorePattern": "^_" 
    }],
    "prefer-const": "error",
    "no-var": "error",
    
    // CUI Standards - Code Quality Rules
    "prettier/prettier": "error",
    
    // CUI Standards - Cypress Rules (Adapted for Best Practices)
    "cypress/no-unnecessary-waiting": "warn",        // Encourage proper element waiting
    "cypress/unsafe-to-chain-command": "off",        // Allow chaining for common Cypress patterns
    "cypress/no-assigning-return-values": "error",   // Prevent async handling issues
    
    // CUI Standards - JSDoc Documentation Requirements (Cypress-adapted)
    "jsdoc/require-description": "error",
    "jsdoc/require-param-description": "error", 
    "jsdoc/require-returns-description": "error",
    "jsdoc/require-example": "warn",
    "jsdoc/no-undefined-types": "off",               // Allow jQuery types
    
    // CUI Standards - Code Complexity Rules (Cypress-adapted)
    "complexity": ["warn", 20],                      // Increased for Cypress test complexity
    "max-depth": ["warn", 5],                        // Increased for nested describes/its
    "max-lines-per-function": ["warn", 200],         // Cypress test functions can be large
    "max-params": ["error", 5],
    
    // CUI Standards - Security Rules
    "security/detect-object-injection": "warn",
    "security/detect-non-literal-regexp": "warn",
    
    // CUI Standards - Code Quality from SonarJS (Cypress-adapted)
    "sonarjs/cognitive-complexity": ["warn", 25],    // Increased for Cypress test complexity
    "sonarjs/no-duplicate-string": "off",            // Handle via constants instead
    "sonarjs/no-identical-functions": "warn",        // Allow similar test patterns
    
    // CUI Standards - Additional Quality Rules
    "unicorn/filename-case": ["error", { "case": "kebabCase" }],
    "unicorn/no-null": "off",                        // Allow null for Cypress compatibility
  },
  
  // File-specific overrides
  overrides: [
    {
      files: ["cypress/e2e/**/*.cy.js", "cypress/integration/**/*.cy.js"],
      rules: {
        "max-lines-per-function": "off",             // Tests can be very large
        "complexity": "off",                         // Tests naturally complex
        "sonarjs/cognitive-complexity": "off",       // Tests naturally complex
        "sonarjs/no-duplicate-string": "off",        // Allow duplicate strings in test files
        "jsdoc/require-jsdoc": "off",               // Don't require JSDoc for test functions
        "jsdoc/require-description": "off",
        "jsdoc/require-param-description": "off",
        "jsdoc/require-returns-description": "off",
        "jsdoc/require-example": "off",
        "jsdoc/no-undefined-types": "off",          // Allow undefined types in tests
        "cypress/unsafe-to-chain-command": "off",   // Allow chaining in tests  
        "cypress/no-unnecessary-waiting": "off",    // Allow waits in tests
        "no-unused-vars": "warn"                    // Keep as warning for cleanup
      }
    },
    {
      files: ["cypress/support/**/*.js"],
      rules: {
        "max-lines-per-function": ["warn", 150],    // Support functions can be larger
        "complexity": ["warn", 20],
        "sonarjs/cognitive-complexity": ["warn", 15],
        "jsdoc/require-jsdoc": "off",              // Relaxed JSDoc for commands
        "security/detect-object-injection": "off", // Dynamic property access needed
        "cypress/unsafe-to-chain-command": "off",  // Allow chaining in support files
        "cypress/no-unnecessary-waiting": "off",   // Allow necessary waits
        "sonarjs/no-duplicate-string": "off"       // Allow duplicate strings
      }
    },
    {
      files: ["cypress/selftests/**/*.cy.js"],
      rules: {
        "max-lines-per-function": "off",           // Complete flexibility
        "complexity": "off",                       // No complexity limits
        "sonarjs/cognitive-complexity": "off",     // No constraints
        "sonarjs/no-duplicate-string": "off",      // Allow duplicate strings
        "jsdoc/require-jsdoc": "off",             // No documentation required
        "cypress/unsafe-to-chain-command": "off", // Full chaining freedom
        "cypress/no-unnecessary-waiting": "off",  // Allow waits
        "no-unused-vars": "warn"
      }
    }
  ]
};
----

== Zero-Warning Achievement Standards

=== Implementation Success Metrics
Successful Cypress ESLint implementations must achieve:

* **98 warnings → 0 warnings** through strategic rule configuration
* **Zero Prettier formatting errors** through consistent formatting
* **Clean Maven builds** with integrated linting validation
* **Maintainable codebase** with consistent standards
* **Security compliance** with vulnerability detection enabled

=== Maven Integration Requirements

==== Build Phase Integration
ESLint validation must be integrated into Maven build lifecycle:

[source,xml]
----
<plugin>
    <groupId>com.github.eirslett</groupId>
    <artifactId>frontend-maven-plugin</artifactId>
    <executions>
        <execution>
            <id>npm-lint</id>
            <goals>
                <goal>npm</goal>
            </goals>
            <phase>validate</phase>
            <configuration>
                <arguments>run lint:check</arguments>
            </configuration>
        </execution>
    </executions>
</plugin>
----

==== Required NPM Scripts
Projects must provide these standardized scripts:

[source,json]
----
{
  "scripts": {
    "lint": "eslint 'cypress/**/*.js'",
    "lint:fix": "eslint 'cypress/**/*.js' --fix", 
    "lint:check": "eslint 'cypress/**/*.js' --max-warnings 0",
    "format": "prettier --write 'cypress/**/*.js'",
    "format:check": "prettier --check 'cypress/**/*.js'"
  }
}
----

**Zero-Warning Policy**: The `--max-warnings 0` flag enforces zero tolerance for warnings in CI/CD pipelines.

=== Required Dependencies

==== Core ESLint Dependencies
[source,json]
----
{
  "devDependencies": {
    "eslint": "^8.57.1",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-cypress": "^3.5.0",
    "eslint-plugin-jsdoc": "^46.8.0",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-security": "^2.1.1",
    "eslint-plugin-sonarjs": "^0.25.1",
    "eslint-plugin-unicorn": "^52.0.0",
    "prettier": "^3.4.2"
  }
}
----

=== Shared Constants Architecture
All Cypress projects must implement a comprehensive shared constants system to eliminate duplicate strings and improve maintainability.

==== Constants File Structure
[source,javascript]
----
// cypress/support/constants.js
/**
 * Shared constants for CUI standards compliance
 * Eliminates duplicate strings across the codebase
 */

// UI Selectors
export const SELECTORS = {
  // Dialog selectors
  DIALOG: '[role="dialog"], .mat-dialog-container, .dialog',
  CONFIGURATION_DIALOG: '.configuration-dialog',
  
  // Common test ID selectors  
  PROCESSOR_DETAILS_METRICS: '[data-testid="processor-details-metrics"]',
  CONFIG_DIALOG_TABS: '[data-testid="config-dialog-tabs"]',
  
  // Data-tab selectors
  METRICS_TAB: '[data-tab="metrics"]',
  PROPERTIES_TAB: '[data-tab="properties"]'
};

// Text Constants
export const TEXT_CONSTANTS = {
  // Common assertions
  BE_VISIBLE: 'be.visible',
  BE_ENABLED: 'be.enabled',
  EXIST: 'exist',
  NOT_EXIST: 'not.exist',
  CONTAIN_TEXT: 'contain.text',
  
  // Button text
  APPLY: 'Apply',
  CANCEL: 'Cancel',
  SAVE: 'Save'
};

// Test Data
export const TEST_DATA = {
  // Test values
  VALID_USERNAME: 'testuser',
  TEST_ISSUER_URL: 'https://test.example.com',
  
  // Processor states
  RUNNING: 'RUNNING',
  STOPPED: 'STOPPED'
};

// Timeouts
export const TIMEOUTS = {
  SHORT: 1000,
  MEDIUM: 2000,
  LONG: 5000,
  VERY_LONG: 10000
};
----

==== Import Requirements
All test files must import required constants:

[source,javascript]
----
// Required imports for test files
import { SELECTORS, TEXT_CONSTANTS, TEST_DATA } from '../support/constants.js';

// Usage in tests
cy.get(SELECTORS.CONFIGURATION_DIALOG).should(TEXT_CONSTANTS.BE_VISIBLE);
cy.configureProcessor(processorId, {
  'JWKS Type': TEST_DATA.SERVER,
  'Default Issuer': TEST_DATA.TEST_ISSUER_URL
});
----

=== Duplicate String Elimination
==== SonarJS Configuration
[source,javascript]
----
// Enforce duplicate string elimination
"sonarjs/no-duplicate-string": ["error", {
  "threshold": 3  // Flag strings repeated 3+ times
}]
----

==== Common Pattern Replacements
[source,javascript]
----
// Before: Duplicate strings
cy.get('.configuration-dialog').should('be.visible');
cy.get('.configuration-dialog').contains('Apply').click();

// After: Using constants
cy.get(SELECTORS.CONFIGURATION_DIALOG).should(TEXT_CONSTANTS.BE_VISIBLE);
cy.get(SELECTORS.CONFIGURATION_DIALOG).contains(TEXT_CONSTANTS.APPLY).click();
----

== Security Standards

=== Object Injection Prevention
Cypress tests must avoid object injection vulnerabilities when handling dynamic data:

==== Safe Array Access
[source,javascript]
----
// Vulnerable: Direct array access with user input
const position = positions[index];  // ❌ Security risk

// Safe: Using .at() method with bounds checking
const safeIndex = Math.max(0, Math.min(index, positions.length - 1));
const position = positions.at(safeIndex) || { x: 100, y: 100 };  // ✅ Secure
----

==== Dynamic Property Access
[source,javascript]
----
// Vulnerable: Direct property access
const value = data[propertyName];  // ❌ Security risk

// Safe: Explicit property access with validation
const allowedProperties = ['name', 'url', 'type'];
const value = allowedProperties.includes(propertyName) 
  ? data[propertyName] 
  : null;  // ✅ Secure
----

== Wait Strategy Standards

=== Eliminate Arbitrary Waits
Replace all arbitrary `cy.wait()` calls with condition-based waits:

==== Anti-Pattern
[source,javascript]
----
// ❌ Arbitrary wait - unreliable and slow
cy.wait(2000);
cy.get('.element').click();
----

==== Correct Pattern
[source,javascript]
----
// ✅ Condition-based wait - reliable and efficient
cy.get('.element', { timeout: TIMEOUTS.MEDIUM }).should(TEXT_CONSTANTS.BE_VISIBLE);
cy.get('.element').click();
----

=== Wait Utilities
Create reusable wait utilities for common patterns:

[source,javascript]
----
// cypress/support/wait-utils.js
export function waitForVisible(selector, timeout = TIMEOUTS.MEDIUM) {
  cy.get(selector, { timeout }).should(TEXT_CONSTANTS.BE_VISIBLE);
}

export function waitForProcessorState(processorId, state, timeout = TIMEOUTS.LONG) {
  cy.get(`[id="${processorId}"]`, { timeout })
    .should('have.attr', 'data-state', state);
}
----

== Plugin Requirements

=== Essential Cypress Plugins
All Cypress projects must include these ESLint plugins:

[source,json]
----
{
  "extends": [
    "plugin:cypress/recommended"
  ],
  "plugins": [
    "cypress",
    "@typescript-eslint",
    "jsdoc",
    "sonarjs", 
    "security",
    "unicorn"
  ]
}
----

=== Plugin-Specific Rules
[source,javascript]
----
{
  "cypress/no-unnecessary-waiting": "warn",
  "cypress/no-force": "error",
  "cypress/assertion-before-screenshot": "warn",
  "security/detect-object-injection": "error",
  "sonarjs/no-duplicate-string": ["error", { "threshold": 3 }]
}
----

== Code Organization Standards

=== Test File Structure
[source,javascript]
----
/**
 * Test file header with description
 * @fileoverview End-to-End tests for [Component/Feature]
 */

// Required imports
import { SELECTORS, TEXT_CONSTANTS, TEST_DATA } from '../support/constants.js';

describe('[Feature] Tests', () => {
  beforeEach(() => {
    // Setup using shared utilities
    cy.nifiLogin(TEST_DATA.ADMIN_USERNAME, TEXT_CONSTANTS.ADMIN_PASSWORD);
    cy.navigateToCanvas();
  });

  it('should [specific behavior]', () => {
    // Test implementation using constants
    cy.get(SELECTORS.PROCESSOR).should(TEXT_CONSTANTS.BE_VISIBLE);
  });
});
----

=== Command Organization
[source,javascript]
----
// cypress/support/commands/[domain].js
/**
 * Domain-specific custom commands
 * @namespace Cypress.Commands
 */

import { SELECTORS, TEXT_CONSTANTS } from '../constants.js';

Cypress.Commands.add('commandName', (param1, param2) => {
  // Implementation using shared constants
  cy.get(SELECTORS.TARGET_ELEMENT).should(TEXT_CONSTANTS.BE_VISIBLE);
});
----

== Validation and Compliance

=== ESLint Configuration Validation
Projects must maintain ESLint configurations that balance CUI standards with Cypress testing needs:

[source,javascript]
----
// Minimum required configuration
{
  "env": {
    "cypress/globals": true
  },
  "extends": [
    "@cuioss/eslint-config",
    "plugin:cypress/recommended"
  ],
  "overrides": [
    {
      "files": ["**/*.cy.js"],
      "rules": {
        "max-lines-per-function": ["error", { "max": 200 }],
        "complexity": ["error", { "max": 25 }]
      }
    }
  ]
}
----

=== Quality Metrics
Projects should achieve these quality thresholds:

* **Duplicate Strings**: < 5% of total string literals
* **Security Warnings**: 0 object injection vulnerabilities  
* **Wait Strategy**: 0 arbitrary `cy.wait()` calls
* **Constants Usage**: > 90% of selectors use shared constants
* **Import Compliance**: 100% of files import required constants

== Implementation Checklist

=== Phase 1: Infrastructure Setup
- [ ] Create `cypress/support/constants.js` with required categories
- [ ] Implement ESLint configuration with Cypress-specific overrides
- [ ] Add required plugins and dependencies
- [ ] Create wait utilities and helper functions

=== Phase 2: Constants Migration  
- [ ] Identify and extract duplicate strings to constants
- [ ] Add imports to all test files
- [ ] Replace hardcoded selectors with `SELECTORS` constants
- [ ] Replace assertions with `TEXT_CONSTANTS` 
- [ ] Replace test data with `TEST_DATA` constants

=== Phase 3: Security and Quality
- [ ] Fix object injection patterns with safe array access
- [ ] Replace arbitrary waits with condition-based waits
- [ ] Remove console.log statements (replace with cy.log)
- [ ] Add JSDoc comments for complex test functions

=== Phase 4: Validation
- [ ] Run ESLint and achieve target warning thresholds
- [ ] Validate security scan results (0 injection vulnerabilities)
- [ ] Confirm constants usage metrics (>90% compliance)
- [ ] Test suite execution validation

== Benefits

=== Maintainability
* **Centralized Changes**: Update selectors in one place
* **Reduced Duplication**: Eliminate repeated string literals
* **Clear Dependencies**: Explicit imports show test requirements

=== Security  
* **Injection Prevention**: Safe array and object access patterns
* **Input Validation**: Controlled dynamic property access
* **Audit Trail**: Security patterns are easily reviewable

=== Reliability
* **Condition-Based Waits**: More reliable than arbitrary delays
* **Consistent Selectors**: Reduced test brittleness
* **Framework Best Practices**: Aligned with Cypress recommendations

=== Team Efficiency
* **Onboarding**: New developers understand patterns quickly
* **Code Reviews**: Standards provide clear evaluation criteria  
* **Debugging**: Constants make test failures easier to diagnose

== Conclusion

These Cypress-specific standards extend CUI JavaScript standards to accommodate the unique requirements of E2E testing while maintaining code quality, security, and maintainability. The framework-specific adaptations ensure that tests remain readable and maintainable while adhering to enterprise development standards.

**Key Principle**: These accommodations apply ONLY to Cypress test files and should never be used for application code, which must continue to follow the base CUI JavaScript standards without modification.

== Console Error Management Standards

=== Zero-Error Policy Implementation
Console error management is critical for maintaining application quality. Cypress tests must actively monitor and validate browser console output.

==== Allowed Warnings Architecture
Implement a centralized allowed warnings system:

[source,javascript]
----
// cypress/support/console-warnings-allowlist.js
module.exports = [
  // Third-party library warnings that cannot be fixed
  'Warning: validateDOMNesting(...): <div> cannot appear as a descendant of <p>.',
  'DevTools failed to load source map',
  'Content Security Policy violation for inline script',
  
  // Deprecated API usage warnings from third-party libraries
  'Synchronous XMLHttpRequest on the main thread is deprecated',
  
  // Browser-specific warnings (document with browser prefix)
  '[Firefox] Unable to preventdefault inside passive event listener',
  '[Chrome] Provider for: vscode-resource'
];
----

==== Console Monitoring Implementation
[source,javascript]
----
// cypress/support/console-error-tracking.js
const allowedWarnings = require('./console-warnings-allowlist');

Cypress.on('window:before:load', (win) => {
  // Store original console methods
  const originalConsole = {
    error: win.console.error,
    warn: win.console.warn,
  };

  // Collection arrays
  win.consoleErrors = [];
  win.consoleWarnings = [];

  // Override console.error
  win.console.error = (...args) => {
    originalConsole.error(...args);
    const message = args
      .map((arg) => (typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)))
      .join(' ');
    win.consoleErrors.push(message);
  };

  // Override console.warn  
  win.console.warn = (...args) => {
    originalConsole.warn(...args);
    const message = args
      .map((arg) => (typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)))
      .join(' ');
    
    // Only track warnings not in allowlist
    if (!allowedWarnings.some((allowedMsg) => message.includes(allowedMsg))) {
      win.consoleWarnings.push(message);
    }
  };
});

// Custom commands for verification
Cypress.Commands.add('verifyNoConsoleErrors', () => {
  cy.window().then((win) => {
    const errors = win.consoleErrors || [];
    if (errors.length > 0) {
      const errorMessages = errors.map((msg) => `- ${msg}`).join('\n');
      throw new Error(`${errors.length} console error(s) detected:\n${errorMessages}`);
    }
  });
});

Cypress.Commands.add('verifyNoUnexpectedWarnings', () => {
  cy.window().then((win) => {
    const warnings = win.consoleWarnings || [];
    if (warnings.length > 0) {
      const warningMessages = warnings.map((msg) => `- ${msg}`).join('\n');
      throw new Error(`${warnings.length} unexpected console warning(s) detected:\n${warningMessages}`);
    }
  });
});
----

==== Console Error Analysis Tool
Projects must implement automated console error analysis:

[source,javascript]
----
// scripts/analyze-console-errors.js
const fs = require('fs');
const path = require('path');
const allowedWarnings = require('../cypress/support/console-warnings-allowlist');

function analyzeConsoleErrors(runId) {
  const logPath = path.join(__dirname, '..', 'cypress', 'logs', `run-${runId}.json`);
  
  if (!fs.existsSync(logPath)) {
    return {
      summary: {
        totalErrors: 0,
        totalUnexpectedWarnings: 0,
        totalAllowedWarnings: 0,
        logFileFound: false
      },
      errors: [],
      unexpectedWarnings: [],
      allowedWarningsByPattern: {}
    };
  }

  const logs = JSON.parse(fs.readFileSync(logPath, 'utf8'));
  const errors = [];
  const unexpectedWarnings = [];
  const allowedWarningInstances = [];

  logs.forEach(log => {
    if (log.type === 'error') {
      errors.push({
        message: log.message,
        source: log.source,
        testFile: log.testFile,
        testName: log.testName
      });
    } else if (log.type === 'warning') {
      const isAllowed = allowedWarnings.some(pattern => 
        log.message.includes(pattern)
      );

      if (isAllowed) {
        allowedWarningInstances.push({
          message: log.message,
          pattern: allowedWarnings.find(pattern => log.message.includes(pattern)),
          source: log.source,
          testFile: log.testFile
        });
      } else {
        unexpectedWarnings.push({
          message: log.message,
          source: log.source,
          testFile: log.testFile,
          testName: log.testName
        });
      }
    }
  });

  return {
    summary: {
      totalErrors: errors.length,
      totalUnexpectedWarnings: unexpectedWarnings.length,
      totalAllowedWarnings: allowedWarningInstances.length,
      logFileFound: true
    },
    errors,
    unexpectedWarnings,
    allowedWarningsByPattern: groupByPattern(allowedWarningInstances)
  };
}

// Exit with error code if issues found
if (require.main === module) {
  const runId = process.argv[2] || new Date().toISOString().replace(/[:.]/g, '-');
  const report = analyzeConsoleErrors(runId);
  
  if (report.summary.totalErrors > 0 || report.summary.totalUnexpectedWarnings > 0) {
    console.error('❌ Console issues detected!');
    process.exit(1);
  } else {
    console.log('✅ No console issues detected.');
    process.exit(0);
  }
}

module.exports = { analyzeConsoleErrors };
----

=== Management Process
1. **All Console Errors Fail Tests**: Default behavior causes test failure
2. **Limited Warning Allowlist**: Only documented, unavoidable warnings allowed
3. **Regular Reviews**: Quarterly review of allowed warnings list
4. **Clear Documentation**: Each allowed warning requires justification
5. **Root Cause Resolution**: Address warnings rather than allowing them

=== Adding to Allowlist Process
1. Create ticket documenting the warning
2. Investigate root cause thoroughly  
3. Determine if fixable in application code
4. If unfixable, document justification with:
   - Exact warning pattern
   - Source of warning
   - Reason it cannot be fixed
   - Impact assessment
   - Future mitigation plan
   - Review date
5. Add to allowlist with explanatory comment

== Best Practices for Zero-Warning Compliance

=== Element Interaction Patterns

==== Prefer Assertions Over Waits
[source,javascript]
----
// ❌ Avoid: Arbitrary waits (unreliable and slow)
cy.wait(1000);
cy.get('.element').click();

// ✅ Prefer: Element-based assertions (reliable and efficient)
cy.get(SELECTORS.TARGET_ELEMENT, { timeout: TIMEOUTS.MEDIUM })
  .should(TEXT_CONSTANTS.BE_VISIBLE)
  .click();
----

==== Robust Element Selection
[source,javascript]
----
// ❌ Avoid: Fragile selectors
cy.get('.some-generated-class-xyz123');

// ✅ Prefer: Stable selectors from constants
cy.get(SELECTORS.PROCESSOR_ELEMENT);

// ✅ Even better: Data attributes
cy.get('[data-testid="processor-element"]');
----

=== Constants Usage Patterns

==== Comprehensive Import Strategy
[source,javascript]
----
// Required imports for all test files
import { 
  SELECTORS, 
  TEXT_CONSTANTS, 
  TEST_DATA, 
  TIMEOUTS 
} from '../support/constants.js';

// Usage in test implementations
describe('Processor Configuration', () => {
  it('should configure authentication processor', () => {
    cy.get(SELECTORS.PROCESSOR).should(TEXT_CONSTANTS.BE_VISIBLE);
    cy.contains(TEXT_CONSTANTS.MULTI_ISSUER_JWT_TOKEN_AUTHENTICATOR);
    cy.configureProcessor(processorId, {
      'JWKS Type': TEST_DATA.SERVER_TYPE,
      'JWKS URL': TEST_DATA.TEST_JWKS_JSON_URL
    });
  });
});
----

==== Constants for Complex Selectors
[source,javascript]
----
// Instead of repeating complex selectors
export const SELECTORS = {
  // Complex multi-part selectors
  PROCESSOR_CONFIG_DIALOG: '[role="dialog"], .mat-dialog-container, .dialog, .add-component-dialog',
  CONTEXT_MENU: '.context-menu, .mat-menu-panel, [role="menu"]',
  
  // Data-driven selectors  
  PROCESSOR_BY_TYPE: (type) => `g.processor[data-type="${type}"]`,
  PROPERTY_ROW: (propertyName) => `[data-property="${propertyName}"]`
};
----

=== Security Pattern Implementation

==== Safe Dynamic Access
[source,javascript]
----
// ❌ Vulnerable: Direct array access
const item = items[userIndex];

// ✅ Secure: Bounds-checked access
const safeIndex = Math.max(0, Math.min(userIndex, items.length - 1));
const item = items.at(safeIndex) || defaultItem;

// ❌ Vulnerable: Dynamic property access  
const value = config[userProperty];

// ✅ Secure: Validated property access
const allowedProperties = ['name', 'url', 'type', 'enabled'];
const value = allowedProperties.includes(userProperty) 
  ? config[userProperty] 
  : null;
----

==== Input Validation for Custom Commands
[source,javascript]
----
/**
 * Secure custom command with input validation
 * @param {string} processorType - Must be from allowed list
 * @param {Object} options - Configuration options
 * @returns {Cypress.Chainable<string>} Processor ID
 */
Cypress.Commands.add('addProcessor', (processorType, options = {}) => {
  // Input validation
  const allowedTypes = [
    'MultiIssuerJWTTokenAuthenticator',
    'GenerateFlowFile',
    'UpdateAttribute'
  ];
  
  if (!allowedTypes.includes(processorType)) {
    throw new Error(`Invalid processor type: ${processorType}`);
  }
  
  // Safe implementation
  cy.get(SELECTORS.CANVAS_SELECTOR)
    .should(TEXT_CONSTANTS.BE_VISIBLE)
    .rightclick();
    
  cy.contains(processorType).click();
});
----

=== Documentation Requirements

==== Support Function Documentation
[source,javascript]
----
/**
 * Configures processor with comprehensive validation
 * @param {string} processorId - Unique processor identifier
 * @param {Object} configuration - Processor configuration
 * @param {string} configuration.name - Processor display name
 * @param {Object} configuration.properties - Key-value property pairs
 * @param {number} [configuration.timeout=5000] - Operation timeout in milliseconds
 * @returns {Cypress.Chainable<void>} Chainable for further operations
 * @throws {Error} When processor ID is invalid or configuration malformed
 * @example
 * cy.configureProcessor('proc-123', {
 *   name: 'JWT Authenticator',
 *   properties: {
 *     'JWKS Type': 'Server',
 *     'JWKS URL': 'https://localhost:8443/certs'
 *   }
 * });
 */
Cypress.Commands.add('configureProcessor', (processorId, configuration) => {
  // Implementation with comprehensive error handling
});
----

=== Error Handling Patterns

==== Graceful Failure Handling
[source,javascript]
----
// Handle element not found gracefully
cy.get('body').then($body => {
  if ($body.find(SELECTORS.OPTIONAL_ELEMENT).length > 0) {
    cy.get(SELECTORS.OPTIONAL_ELEMENT).click();
  } else {
    cy.log('Optional element not present, skipping interaction');
  }
});

// Retry mechanism for flaky operations
Cypress.Commands.add('retryOperation', (operation, maxRetries = 3) => {
  const attempt = (retriesLeft) => {
    if (retriesLeft === 0) {
      throw new Error('Operation failed after maximum retries');
    }
    
    try {
      operation();
    } catch (error) {
      cy.log(`Operation failed, ${retriesLeft - 1} retries remaining`);
      cy.wait(TIMEOUTS.SHORT);
      attempt(retriesLeft - 1);
    }
  };
  
  attempt(maxRetries);
});
----

== Troubleshooting Common Issues

=== ESLint Configuration Issues

==== Issue: "unsafe-to-chain-command" Errors
**Symptom**: ESLint flags Cypress chaining as unsafe  
**Solution**: Rule is disabled in configuration - verify `.eslintrc.js` is current
[source,javascript]
----
// Ensure this rule is disabled
"cypress/unsafe-to-chain-command": "off"
----

==== Issue: Duplicate String Warnings  
**Symptom**: SonarJS flags repeated strings  
**Solution**: Add strings to constants and import them
[source,javascript]
----
// 1. Add to constants.js
export const NEW_CONSTANT = 'repeated-string-value';

// 2. Import in test files
import { NEW_CONSTANT } from '../support/constants';

// 3. Use instead of string literals
cy.contains(NEW_CONSTANT);
----

==== Issue: Function Too Complex
**Symptom**: Functions exceed complexity thresholds  
**Solutions**:
1. Break into smaller, focused functions
2. Move complex logic to support files
3. Use data-driven test patterns
4. Extract helper functions for repetitive operations

==== Issue: Missing JSDoc Documentation
**Symptom**: Support functions lack required documentation  
**Solution**: Add comprehensive JSDoc comments
[source,javascript]
----
/**
 * Brief description of function purpose
 * @param {type} paramName - Parameter description
 * @param {type} [optionalParam] - Optional parameter description  
 * @returns {type} Return value description
 * @throws {Error} Error conditions description
 * @example
 * functionName('example', { option: true });
 */
----

=== Test Execution Issues

==== Issue: Flaky Test Failures
**Symptoms**: Tests pass/fail inconsistently  
**Solutions**:
1. Replace `cy.wait()` with proper assertions
2. Increase timeouts for slow operations
3. Add retry logic for unreliable operations  
4. Use more specific selectors

==== Issue: Element Not Found
**Symptoms**: Tests fail with "element not found"  
**Solutions**:
1. Verify selectors match current DOM structure
2. Add explicit waits for dynamic content
3. Check element visibility before interaction
4. Use data-testid attributes for stability

==== Issue: Console Error Test Failures
**Symptoms**: Tests fail due to console errors/warnings  
**Solutions**:
1. Investigate and fix root cause first
2. For unfixable third-party issues, add to allowlist
3. Document justification for each allowed warning
4. Regular review and cleanup of allowlist

=== Performance Optimization

==== Reduce Test Execution Time
[source,javascript]
----
// Use efficient selectors
cy.get('[data-testid="specific-element"]'); // Fast
cy.get('.class-name:nth-child(3)');        // Slower

// Batch operations when possible
cy.get(SELECTORS.FORM_CONTAINER).within(() => {
  cy.get('[name="username"]').type(TEST_DATA.USERNAME);
  cy.get('[name="password"]').type(TEST_DATA.PASSWORD);
  cy.get('[type="submit"]').click();
});

// Use constants to avoid repeated selector parsing
const processor = cy.get(SELECTORS.PROCESSOR);
processor.should(TEXT_CONSTANTS.BE_VISIBLE);
processor.click();
----

==== Optimize Waiting Strategies
[source,javascript]
----
// Efficient: Specific condition waits
cy.get(SELECTORS.LOADING_SPINNER).should('not.exist');
cy.get(SELECTORS.CONTENT).should(TEXT_CONSTANTS.BE_VISIBLE);

// Avoid: Generic long waits
cy.wait(5000); // Inefficient and unreliable
----

=== Configuration Maintenance

==== Updating ESLint Rules
**Process**:
1. Test impact on existing codebase
2. Update documentation to reflect changes
3. Communicate changes to development team
4. Provide migration guidance for existing code
5. Monitor for new issues after implementation

==== Adding New ESLint Plugins
**Evaluation Criteria**:
1. Does plugin address real quality issues?
2. Is it actively maintained and well-documented?
3. Does it align with CUI standards?
4. What is the impact on existing code?

**Implementation Process**:
1. Test plugin on sample codebase
2. Document new rules and rationale
3. Consider gradual rollout (warning before error)
4. Update project documentation

==== Constants Management
**Best Practices**:
1. Group constants by category (selectors, text, data)
2. Use descriptive names that indicate usage context
3. Regular cleanup of unused constants
4. Version control for constants changes
5. Cross-reference with test files for usage tracking

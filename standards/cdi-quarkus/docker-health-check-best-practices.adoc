= Docker Health Check Best Practices for Quarkus Applications
:toc:
:icons: font

This document provides detailed implementation guidance for Docker health checks in Quarkus applications. For overall container standards including base image selection and security requirements, see xref:container-standards.adoc[Container Standards].

== Purpose

This document focuses on the practical implementation of efficient, secure health checks that avoid external dependencies and provide meaningful application health validation.

== Core Principle

**Use internal health check scripts with built-in system tools only** - avoid external dependencies like `curl`, `wget`, or similar tools.

== Why Avoid External Dependencies in Health Checks?

=== Issues with `curl` and External Tools

[NOTE]
====
Based on research from Docker community best practices and expert recommendations:
====

* **Image Bloat**: Adding `curl` increases image size (~2.5MB) and attack surface
* **Portability Issues**: Creates cross-platform compatibility problems
* **Maintenance Overhead**: Requires maintaining external tools and their dependencies
* **Security Concerns**: External diagnostic endpoints need to be kept private
* **Dependency Risk**: Tool availability varies across base images (e.g., UBI9 has `curl` conflicts)

== Recommended Approach: Internal Health Check Scripts

=== Implementation Strategy

Create application-specific health check scripts using only built-in commands:

```bash
#!/bin/bash
# Internal health check script
# Uses /dev/tcp for connection testing (Docker best practice)

# Check if application port is listening using /dev/tcp
# This approach is preferred over /proc/net/tcp parsing
if ! echo -n '' > /dev/tcp/127.0.0.1/8443 2>/dev/null; then
    echo "Application not listening on port 8443"
    exit 1
fi

# Check application-specific health indicators
if [ ! -f "/app/certificates/keystore.p12" ]; then
    echo "Certificate files missing"
    exit 1
fi

# Check if application executable exists and is executable
if [ ! -x "/app/application" ]; then
    echo "Application executable missing or not executable"
    exit 1
fi

echo "Health check passed"
exit 0
```

=== Dockerfile Integration

**For distroless images (production)**:
```dockerfile
# Copy with proper permissions
COPY --chmod=0755 health-check.sh /app/health-check.sh

# Health check configuration
HEALTHCHECK --interval=30s --timeout=10s --retries=3 --start-period=40s \
  CMD /app/health-check.sh
```

**For UBI9 images (development)**:
```dockerfile
# Copy health check script
COPY health-check.sh /app/health-check.sh

# Set permissions using RUN command
RUN chmod u+x /app/health-check.sh

# Health check configuration
HEALTHCHECK --interval=30s --timeout=10s --retries=3 --start-period=40s \
  CMD /app/health-check.sh
```

=== Docker Compose Configuration

```yaml
services:
  app:
    healthcheck:
      test: ["CMD", "/app/health-check.sh"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
```

== Alternative: Quarkus Native Health Checks

For even better integration, implement custom health checks using Quarkus's built-in mechanisms:

```java
@Liveness
@ApplicationScoped
public class CustomHealthCheck implements HealthCheck {

    @Override
    public HealthCheckResponse call() {
        boolean isHealthy = performHealthCheck();
        
        if (isHealthy) {
            return HealthCheckResponse.up("Application Service");
        } else {
            return HealthCheckResponse.down("Application Service");
        }
    }

    private boolean performHealthCheck() {
        try {
            // Check application-specific health indicators
            // - Certificate files existence
            // - Database connectivity
            // - Critical service dependencies
            var keystoreExists = java.nio.file.Files.exists(
                java.nio.file.Paths.get("/app/certificates/keystore.p12"));
            
            return keystoreExists;
        } catch (Exception e) {
            return false;
        }
    }
}
```

== Key Principles

=== Design Guidelines

* **Keep It Simple**: Use straightforward commands that execute quickly
* **Meaningful Checks**: Test actual functionality, not just process existence
* **Application-Aware**: Validate application-specific health indicators
* **No External Dependencies**: Avoid tools like `curl`, `wget`, or `ping`
* **Cross-Platform**: Ensure health checks work across all architectures

=== Technical Considerations

* **Port Checking**: Use `/dev/tcp` for direct TCP connection testing (preferred over `/proc/net/tcp` parsing)
* **File Validation**: Check critical configuration and certificate files
* **Process Validation**: Use built-in commands or `/proc` filesystem
* **Connection Testing**: `/dev/tcp` tests actual connectivity, not just listening state

== Testing the Implementation

=== Verification Steps

1. **Build and Deploy**: Ensure the application builds and starts correctly
2. **Health Check Test**: Manually execute the health check script
3. **Docker Status**: Verify container shows as "healthy" in `docker ps`
4. **Endpoint Testing**: Validate that application endpoints are accessible
5. **Integration Testing**: Test complete Docker Compose workflow

=== Example Test Commands

```bash
# Test health check script directly
docker exec <container> /app/health-check.sh

# Verify container health status
docker ps --format "table {{.Names}}\t{{.Status}}"

# Check detailed health status and logs
docker inspect <container> --format='{{.State.Health.Status}}'
docker inspect <container> | grep -A 20 '"Health"'

# Test /dev/tcp connectivity directly
docker exec <container> bash -c 'echo -n "" > /dev/tcp/127.0.0.1/8443 && echo "TCP connection successful"'

# Test application endpoints
curl -k https://localhost:10443/q/health/live
curl -k https://localhost:10443/q/health/ready

# Verify startup and recovery behavior
docker compose stop && docker compose up -d
```

== Summary Benefits

* **No External Dependencies**: Works in distroless and minimal base images
* **Security**: Reduced attack surface, no exposed diagnostic endpoints
* **Performance**: Faster execution than HTTP-based checks
* **Reliability**: Tests actual application functionality
* **Maintainability**: Simple scripts with clear validation logic

== Troubleshooting Health Checks

=== Common Health Check Issues

**Health Check Script Not Executable**:
```bash
# Fix permissions issue
docker exec -it container chmod +x /app/health-check.sh
```

**Port Not Accessible**:
```bash
# Test /dev/tcp connectivity manually
docker exec -it container bash -c 'echo -n "" > /dev/tcp/127.0.0.1/8443'

# Check if application is listening
docker exec -it container netstat -tlnp | grep 8443
```

**Certificate File Issues**:
```bash
# Verify certificate files exist and are readable
docker exec -it container ls -la /app/certificates/
docker exec -it container test -r /app/certificates/keystore.p12 && echo "Certificate readable"
```

**Health Check Timeout**:
- Increase timeout in HEALTHCHECK directive if application needs more time
- Optimize health check logic to execute faster
- Ensure health check doesn't perform expensive operations

=== Debugging Health Check Execution

```bash
# Check health check status
docker inspect container --format='{{.State.Health.Status}}'

# View health check logs
docker inspect container --format='{{range .State.Health.Log}}{{.Output}}{{end}}'

# Test health check manually
docker exec -it container /app/health-check.sh
echo $?  # Should return 0 for success
```

== Conclusion

Using internal health check scripts with `/dev/tcp` instead of external tools like `curl` provides better security, portability, and performance while reducing image size and maintenance overhead. The `/dev/tcp` approach is preferred over `/proc/net/tcp` parsing as it tests actual connectivity rather than just port listening state. This approach follows Docker community best practices and ensures reliable health monitoring for production deployments.

For broader container configuration standards including base images, security, and performance requirements, refer to the xref:container-standards.adoc[Container Standards] document.
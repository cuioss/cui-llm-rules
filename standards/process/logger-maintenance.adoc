= Logger Maintenance Process
:toc: left
:toclevels: 3
:toc-title: Table of Contents
:sectnums:
:source-highlighter: highlight.js

[IMPORTANT]
====
This document is governed by the general process rules defined in xref:general.adoc[General Process Rules].
====

Process for implementing and maintaining logging standards while preserving functionality and adhering to CUI logging requirements.

Proceed exactly as described. Proceed in the code class by class. Do not use any scripts to modify but you may use scripts to detect problems.

=== Planning Document
Maintain a `plan.md` file in the module root to track LogRecord test coverage systematically:

.Example plan.md structure
[source,markdown]
----
# LogRecord Test Coverage Status

## Summary
- Total LogRecords: X
- Tested with LogAsserts: Y
- Missing LogAsserts: Z

## LogRecord Inventory
| LogRecord | Production Location | Business Test Location | Status |
|-----------|-------------------|----------------------|--------|
| JWKS_JSON_PARSE_FAILED | WellKnownConfigurationConverter:93 | WellKnownResultConverterTest:204 | ✅ |
| CONTENT_CONVERSION_FAILED | ResilientHttpHandler:142 | ResilientHttpHandlerIntegrationTest:87 | ✅ |
| INVALID_TOKEN_FORMAT | NonValidatingJwtParser:78 | NonValidatingJwtParserTest:123 | ❌ Missing |
----

== Pre-Maintenance Checklist

Execute before starting logger maintenance following xref:task-completion-standards.adoc[Task Completion Standards]:

1. [ ] *Build Verification*: `./mvnw -Ppre-commit clean verify -DskipTests`
2. [ ] *Module Identification*: List all modules for systematic processing
3. [ ] *Logging Standards Review*: Familiarize with xref:../logging/core-standards.adoc[Core Standards], xref:../logging/implementation-guide.adoc[Implementation Guide], and xref:../logging/testing-guide.adoc[Testing Guide]

== Module-by-Module Approach

=== Single Module Process
1. *Module Focus*: Process one module completely before moving to next
2. *Test Execution*: `./mvnw clean test -pl module-name`
3. *Documentation Update*: Ensure `doc/LogMessages.adoc` is current
4. *Commit per Module*: Complete module before next following xref:git-commit-standards.adoc[Git Commit Standards]

=== Multi-Module Strategy
* Process modules in dependency order (dependencies first)
* Maintain build stability after each module
* Verify inter-module logging compatibility

== Logging Standards Implementation

=== Required Changes per xref:../logging/core-standards.adoc[Core Standards]

==== Logger Configuration Issues
* **Wrong Logger Type**: Replace slf4j, log4j, or java.util.logging with CuiLogger
* **Incorrect Declaration**: Ensure `private static final CuiLogger LOGGER = new CuiLogger(ClassName.class)`
* **System.out/err Usage**: Replace with appropriate logger level calls
* **Log Level Prefixes**: Remove manual prefixes like [DEBUG], [ERROR] - use proper log levels

==== LogRecord Implementation Issues
* **Missing LogRecord Usage**: INFO/WARN/ERROR/FATAL must use LogRecord, not direct logging
* **Incorrect LogRecord Usage**: DEBUG/TRACE must NOT use LogRecord - use direct logging only
* **Wrong Parameter Format**: Use '%s' for string substitutions (not '{}' or '%d') - always prefer '%s' over '{}'
* **Exception Handling**: Exception parameter must come first in log calls

==== LogMessages Structure Issues
* **Missing LogMessages Class**: Create module-specific LogMessages following DSL-Style Constants Pattern if the module provides at least 10 Java types or 10 messages of INFO level or higher.
* **Incorrect Hierarchy**: Must be exactly 4 levels deep with category-level imports only
* **ID Range Violations**: INFO (001-099), WARN (100-199), ERROR (200-299), FATAL (300-399)
* **Duplicate IDs**: Ensure unique identifiers within module

=== Documentation Requirements

==== doc/LogMessages.adoc Compliance
* **File Existence**: Must exist for each module with LogMessages if the module provides at least 10 Java types or 10 messages of INFO level or higher.
* **Format Compliance**: Follow specified table structure per xref:../logging/core-standards.adoc[Core Standards]
* **Content Accuracy**: All documented messages must match implementation exactly
* **Complete Coverage**: All INFO/WARN/ERROR/FATAL messages must be documented

== Duplicate Detection and Resolution

=== Common Duplication Patterns
* **Identical Log Messages**: Same message across different components
* **Similar Message Templates**: Messages that could be consolidated
* **Redundant LogRecord Declarations**: Multiple LogRecords for the same purpose
* **Duplicate Error Conditions**: Same error logged in multiple places
* **Mixed Parameter Formats**: Some messages using '{}' and others using '%s' - standardize on '%s'

=== Resolution Strategy
* **Consolidate Messages**: Move common messages to shared LogMessages class
* **Parameterize Templates**: Use parameters instead of multiple similar messages
* **Extract Common Patterns**: Create reusable LogRecord declarations
* **Centralize Error Logging**: Single point of logging for common errors

== Testing Implementation

=== Required Test Coverage per xref:../logging/testing-guide.adoc[Testing Guide]
* **All INFO Level Messages**: Verify content and level
* **All WARN Level Messages**: Verify content and level  
* **All ERROR Level Messages**: Verify content and level
* **All FATAL Level Messages**: Verify content and level
* **Parameter Substitution**: Test all parameter combinations
* **Exception Logging**: Verify exception inclusion

=== Testing Framework Requirements
* **@EnableTestLogger**: Required on all test classes
* **cui-test-juli-logger**: Use for all logging tests
* **LogAsserts Methods**: Use appropriate assertion methods
* **TestLogLevel Constants**: Use for log level verification

== Critical Constraints

=== Production Code Protection
* **LOGGING CODE ONLY**: Only modify logging-related code, no other production changes
* **Bug Discovery**: Must ask user for approval before fixing non-logging production bugs
* **Behavior Preservation**: All existing functionality must continue to work
* **Test-Only Changes**: Focus on logging implementation and testing

=== Bug Handling Process
When non-logging production bugs are discovered:

1. **Stop maintenance process**
2. **Document bug details** (location, issue, impact)
3. **Ask user for approval** to fix non-logging production code
4. **Wait for confirmation** before proceeding
5. **Create separate commit** for bug fix following xref:git-commit-standards.adoc[Git Commit Standards]

== Maintenance Workflow

=== Analysis Phase

==== LogRecord Discovery Script
Use this script to systematically find all LogRecords and their test coverage:

[source,bash]
----
#!/bin/bash
# Find all LogRecords and verify test coverage
echo "=== Finding all LogRecords ==="
grep -r "LogRecord\." --include="*.java" src/main/java | grep -E "(INFO|WARN|ERROR|FATAL)\." | cut -d: -f2- | sort -u

echo "=== Checking for LogAsserts in business tests ==="
for record in $(grep -r "LogRecord\." --include="*.java" src/main/java | grep -oE "[A-Z_]+\.(format|resolveIdentifierString)" | cut -d'.' -f1 | sort -u); do
    echo "LogRecord: $record"
    echo "  Production usage:"
    # Check for both direct calls (.format) and method references (::format)
    grep -rE "$record\.(format|resolveIdentifierString)|$record::format" --include="*.java" src/main/java | head -3
    echo "  Test coverage (must be in business logic test):"
    grep -r "LogAsserts.*$record\|$record.*resolveIdentifierString" --include="*Test.java" src/test/java | head -3
    if [ $? -ne 0 ]; then
        echo "  WARNING: No LogAsserts found for $record"
    fi
done

echo "=== Summary ==="
echo "Update plan.md with findings before proceeding"
----

1. **Logger Audit**: Identify non-CuiLogger usage and system output calls
2. **LogRecord Audit**: Check INFO/WARN/ERROR/FATAL use LogRecord, DEBUG/TRACE use direct logging
3. **LogMessages Review**: Verify structure and ID ranges
4. **Documentation Check**: Ensure doc/LogMessages.adoc exists and matches implementation
5. **Duplicate Detection**: Identify redundant messages and patterns

=== Implementation Phase
1. **Logger Migration**: Replace non-CuiLogger instances
2. **LogRecord Implementation**: Add LogRecord for production levels
3. **LogMessages Creation**: Implement module LogMessages following DSL pattern
4. **Documentation Update**: Create/update doc/LogMessages.adoc
5. **Test Implementation**: Add comprehensive logging tests

=== Verification Phase

==== LogRecord Test Coverage Verification

For each LogRecord, verify it is referenced in at least 2 locations:

1. **Production code**: Where `.format()` is called (or `::format` method reference) to actually log the message
2. **Business logic test**: Where `LogAsserts` verifies the message was logged

.Critical Rules
[WARNING]
====
* If only in production → Add LogAsserts to the EXISTING business logic test
* If not referenced at all → Remove the LogRecord entirely
====

==== Common LogAsserts Patterns

.Correct - In Business Logic Test
[source,java]
----
@Test
void shouldHandleInvalidConfiguration() {
    // Business logic that triggers the error
    service.processInvalidConfig(badConfig);
    
    // Verify the LogRecord was logged
    LogAsserts.assertLogMessagePresentContaining(TestLogLevel.ERROR,
        ERROR.INVALID_CONFIG.resolveIdentifierString());
}
----

.Incorrect - Standalone Coverage Test
[source,java]
----
@Test
void testLogRecordCoverage() { // WRONG - Don't do this!
    LOGGER.error(ERROR.INVALID_CONFIG.format());
    LogAsserts.assertLogMessagePresentContaining(TestLogLevel.ERROR,
        ERROR.INVALID_CONFIG.resolveIdentifierString());
}
----

IMPORTANT:
Do not make "coverage tests" for just the LogRecords: The asserts must always be in conjunction with a sensible Business logic test. Otherwise you failed your task.

Following xref:task-completion-standards.adoc[Task Completion Standards]:

1. **Full Build**: `./mvnw -Ppre-commit clean install`
2. **Documentation Validation**: Verify doc/LogMessages.adoc accuracy
3. **Final Commit**: Consolidate if needed, update module status

== Common Implementation Patterns

=== Logger Migration
**Before:**
```java
private static final Logger logger = LoggerFactory.getLogger(MyClass.class);
System.out.println("Debug info: " + data);
```

**After:**
```java
private static final CuiLogger LOGGER = new CuiLogger(MyClass.class);
LOGGER.debug("Debug info: %s", data);
```

=== LogRecord Implementation
**Before:**
```java
logger.info("User {} logged in successfully", username);
logger.error("Database connection failed: {}", e.getMessage());
```

**After:**
```java
LOGGER.info(INFO.USER_LOGIN.format(username));
LOGGER.error(e, ERROR.DATABASE_CONNECTION.format());
```

**Key Points:**
* Replace slf4j '{}' placeholders with '%s' in LogRecord templates
* Always prefer '%s' over '{}' for parameter substitution
* Use LogRecord.format() for parameterized messages

=== LogMessages Structure
```java
@UtilityClass
public final class ModuleLogMessages {
    public static final String PREFIX = "MODULE";
    
    @UtilityClass
    public static final class INFO {
        public static final LogRecord USER_LOGIN = LogRecordModel.builder()
            .template("User %s logged in successfully")
            .prefix(PREFIX)
            .identifier(1)
            .build();
    }
    
    @UtilityClass 
    public static final class ERROR {
        public static final LogRecord DATABASE_CONNECTION = LogRecordModel.builder()
            .template("Database connection failed")
            .prefix(PREFIX)
            .identifier(200)
            .build();
    }
}
```

=== Test Implementation
```java
@EnableTestLogger
class ServiceTest {
    @Test
    void shouldLogUserLogin() {
        // given
        String username = "testuser";
        
        // when
        service.loginUser(username);
        
        // then -> For cases you want to verify the exact messages
        assertSingleLogMessagePresent(
            TestLogLevel.INFO,
            INFO.USER_LOGIN.format(username));
        // Alternative, if you want to verify only the level and the LogRecord -> Usually sufficient
        assertSingleLogMessagePresentContaining(
            TestLogLevel.INFO,
            INFO.USER_LOGIN.resolveIdentifierString());
    }
}
```

== Troubleshooting Common Issues

=== LogAsserts Failing Despite LogRecord Usage

.Symptom
LogRecord appears to be used but LogAsserts doesn't find the log message

.Diagnosis Steps
1. **Verify actual logging**: Check if LogRecord is logged with `.format()`, not just defined
2. **Check usage type**: Distinguish between logging and counting (e.g., SecurityEventCounter)
3. **Verify log level**: Ensure test checks correct level (WARN vs ERROR)
4. **Confirm code path**: Ensure test actually triggers the logging condition

.Example Investigation
[source,bash]
----
# Check if LogRecord is logged or just counted
grep -B2 -A2 "MY_LOGRECORD" src/main/java/path/to/Class.java
# Look for .format() vs SecurityEventCounter.increment()
----

=== Finding the Right Business Logic Test

.Approach
1. Find where the LogRecord is logged in production code
2. Identify the method/class containing that code
3. Find the corresponding test class (usually ClassName + Test)
4. Find the test method that exercises that code path
5. Add LogAsserts to that existing test

.Never
* Create a new test just for LogRecord coverage
* Test LogRecords in isolation
* Add LogAsserts without verifying the log is actually produced

=== Distinguishing Logged vs Counted LogRecords

Some LogRecords are only used for security event counting, not actual logging:

.Only Counted (No LogAsserts needed)
[source,java]
----
securityEventCounter.increment(EventType.JWKS_JSON_PARSE_FAILED);
// No LOGGER.warn() call with this LogRecord
----

.Actually Logged (LogAsserts required)
[source,java]
----
// Direct method call
LOGGER.warn(JWTValidationLogMessages.WARN.JWKS_JSON_PARSE_FAILED.format(errorMessage));

// Method reference (also needs LogAsserts)
errorMessages.forEach(JWTValidationLogMessages.ERROR.VALIDATION_FAILED::format);

// Both patterns need LogAsserts in the test
----

== Success Criteria

=== Logger Configuration
* Only CuiLogger instances used
* No system output calls
* Proper logger declaration pattern

=== LogRecord Implementation  
* INFO/WARN/ERROR/FATAL use LogRecord
* DEBUG/TRACE use direct logging
* Correct parameter formatting
* Exception handling follows pattern

=== Documentation
* doc/LogMessages.adoc exists and is accurate
* All production messages documented
* Format follows specification

=== Testing
* All production log messages tested
* Tests use cui-test-juli-logger
* Comprehensive parameter and exception coverage

For complete quality verification, see xref:task-completion-standards.adoc[Task Completion Standards].
= Java Test Maintenance Process
:toc:
:toclevels: 2
:sectnums:
:source-highlighter: highlight.js

[IMPORTANT]
====
This document is governed by the general process rules defined in xref:general.adoc[General Process Rules].
====

Process for maintaining and improving Java test quality while preserving functionality and adhering to CUI standards.

== Pre-Maintenance Checklist

Execute before starting test maintenance following xref:task-completion-standards.adoc[Task Completion Standards]:

1. [ ] *Build Verification*: `./mvnw -Ppre-commit clean verify -DskipTests`
2. [ ] *Test Execution*: `./mvnw clean test` - all tests must pass
3. [ ] *Coverage Baseline*: `./mvnw clean verify -Pcoverage` - record current metrics
4. [ ] *Security Test Audit*: Verify security testing patterns and vulnerability coverage
5. [ ] *Module Identification*: List all modules for systematic processing

== Module-by-Module Approach

=== Single Module Process
1. *Module Focus*: Process one module completely before moving to next
2. *Test Execution*: `./mvnw clean test -pl module-name`
3. *Coverage Check*: `./mvnw clean verify -Pcoverage -pl module-name`
4. *Commit per Module*: Complete module before next following xref:git-commit-standards.adoc[Git Commit Standards]

=== Multi-Module Strategy
* Process modules in dependency order (dependencies first)
* Maintain build stability after each module
* Verify inter-module test compatibility

== Test Quality Issues

=== AI-Generated Code Detection
* **Detection Process**: Identify AI artifacts per xref:../testing/quality-standards.adoc#ai-generated-code-detection[Quality Standards AI Detection]
* **Removal Actions**: Apply removal rules as defined in quality standards
* **Process Focus**: Systematic identification and elimination during maintenance cycles

=== Test Enhancement Prioritization

**High Priority - Business Logic Tests:**
* Domain object tests (token content, claims, validators)
* Business rule validation tests
* API contract and behavior tests
* User-facing functionality tests
* Security and compliance tests

**Medium Priority - Value Objects:**
* Data transfer objects with equals/hashCode contracts
* Configuration objects used in business logic
* Domain enums with complex behavior

**Low Priority - Infrastructure Tests:**
* HTTP client/server communication tests
* JWKS loading and caching tests
* Security infrastructure tests (if already comprehensive)
* Build and deployment infrastructure tests
* Framework integration tests

**Infrastructure Test Criteria:**
Tests that should remain as infrastructure (no CUI enhancement needed):
* Test external service integrations
* Test framework behavior rather than business logic
* Already provide adequate coverage through existing patterns
* Would not benefit from generator-based test data

**Classification Documentation Requirements:**
* Maintain test file inventory with enhancement status
* Document justification for infrastructure classification
* Track enhancement completion and coverage impact

=== Duplicate Detection
* **Identical Test Logic**: Consolidate into parameterized tests using JUnit 5 with @GeneratorsSource
* **Similar Test Data**: Extract to shared TypeGenerator implementations
* **Repeated Setup**: Move to `@BeforeEach` or test base classes
* **Copy-Paste Patterns**: Refactor into reusable test methods with generator support
* **Manual Data Duplication**: Replace with consistent generator-based data creation

== CUI Framework Compliance

=== Framework Compliance Requirements

* **Apply Standards**: Follow xref:../testing/core-standards.adoc#cui-framework-requirements[CUI Framework Requirements]
* **Library Restrictions**: Adhere to xref:../testing/quality-standards.adoc#testing-library-restrictions[Testing Library Requirements]
* **Implementation Guide**: Reference xref:../testing/cui-test-generator-guide.adoc[CUI Test Generator Guide] for examples

=== Security Testing Standards

**Security Test Categories:**
* **Attack Simulation Tests**: Verify protection against known attack vectors (JKU/X5U, embedded JWK, KID injection)
* **Vulnerability Regression Tests**: Prevent reintroduction of patched vulnerabilities (CVE-2018-0114, CVE-2022-21449)
* **Security Event Tracking**: Ensure proper logging and monitoring of security events

**Parameterized Security Testing:**
* Use `@TestTokenSource` with count parameters for comprehensive security testing
* Include `SecurityEventCounter` integration for tracking security events
* Verify protection against algorithm confusion attacks

**Example Implementation:**
[source,java]
----
@ParameterizedTest
@TestTokenSource(value = TokenType.ACCESS_TOKEN, count = 3)
@DisplayName("Should reject tokens with tampered payloads")
void shouldRejectTokensWithTamperedPayloads(TestTokenHolder tokenHolder) {
    String validToken = tokenHolder.getRawToken();
    String tamperedToken = tamperTokenPayload(validToken);
    
    assertThrows(TokenValidationException.class,
        () -> validator.createAccessToken(tamperedToken),
        "Should reject token with tampered payload");
        
    assertTrue(securityEventCounter.getCount(SIGNATURE_VALIDATION_FAILED) > 0,
        "Security event should be recorded for tampered token");
}
----

**Count Parameter Guidelines:**
* Use count=2 for basic variation testing
* Use count=3 for security-critical scenarios  
* Use count=5+ for complex business logic with many edge cases

=== Framework Migration Process

1. **Scan for Issues**: Identify violations of CUI framework requirements
2. **Apply Standards**: Follow migration patterns per framework standards
3. **Verify Compliance**: Check against CUI framework requirements
4. **Update Implementation**: Use generator guide examples for correct patterns

== Maintenance Standards

=== Test Structure
Following xref:../testing/core-standards.adoc[Core Standards]:
* Verify AAA pattern (Arrange-Act-Assert)
* Ensure test independence
* Confirm descriptive test names
* Check proper `@DisplayName` usage

=== Coverage Requirements
* Maintain minimum 80% line coverage
* Preserve existing coverage levels
* Identify untested critical paths
* Document coverage gaps

== Critical Constraints

=== Production Code Protection
* **NO PRODUCTION CHANGES** except confirmed bugs
* **Bug Discovery**: Must ask user for approval before fixing production code
* **Test-Only Changes**: Focus solely on test improvement
* **Behavior Preservation**: All existing tests must continue to pass

=== Bug Handling Process
When production bugs are discovered:
1. **Stop maintenance process**
2. **Document bug details** (location, issue, impact)
3. **Ask user for approval** to fix production code
4. **Wait for confirmation** before proceeding
5. **Create separate commit** for bug fix following xref:git-commit-standards.adoc[Git Commit Standards]

== Maintenance Workflow

=== Analysis Phase
1. **Scan for Issues**: Identify AI artifacts, duplicates, and non-compliance
2. **AI Pattern Detection**: Check for method names >75 chars, excessive comments, verbose @DisplayName
3. **Non-Sensible Test Review**: Identify meaningless constructor tests and framework behavior tests
4. **CUI Framework Audit**: Check for manual data creation and missing annotations
5. **Value Object Review**: Identify objects needing contract testing per value object criteria
6. **Security Test Review**: Verify security testing patterns and vulnerability coverage
7. **Classify Test Files**: Apply prioritization framework (High/Medium/Low priority)
8. **Document Classification**: Maintain test file inventory with enhancement status and justification
9. **Prioritize Changes**: Focus on high-priority business logic tests first
10. **Plan Module Order**: Dependencies first, then dependent modules

=== Compliance Verification Checklist
For each test class, verify compliance with:
- [ ] **CUI Framework Standards**: xref:../testing/core-standards.adoc#cui-framework-requirements[Framework Requirements]
- [ ] **Quality Standards**: xref:../testing/quality-standards.adoc#ai-generated-code-detection[AI Detection] and xref:../testing/quality-standards.adoc#testing-library-restrictions[Library Restrictions]
- [ ] **Coverage Requirements**: xref:../testing/quality-standards.adoc#coverage-requirements[Coverage Standards]

=== Implementation Phase
1. **Apply Changes**: Fix one category of issues at a time
2. **Verify Tests**: `./mvnw clean test -pl module-name` after each change
3. **Check Coverage**: Ensure no coverage regression
4. **Commit Incrementally**: Small, focused commits per improvement type

=== Verification Phase
Following xref:task-completion-standards.adoc[Task Completion Standards]:

**Build Profile Standards:**

1. **Quality Build (Fast Feedback)**: `./mvnw -Ppre-commit clean verify -DskipTests -pl <module>`
   * Purpose: Code quality checks without test execution
   * Usage: Development iteration, pre-commit validation
   * Includes: License headers, compilation, static analysis

2. **Verification Build (Comprehensive)**: `./mvnw clean verify -pl <module>`
   * Purpose: Full test suite execution with comprehensive validation
   * Usage: Release preparation, CI/CD pipelines
   * Includes: Complete test suite, coverage analysis, quality gates

3. **Coverage Analysis**: `./mvnw clean verify -Pcoverage -pl <module>`
   * Purpose: Detailed coverage analysis and reporting
   * Usage: Coverage verification, regression detection
   * Includes: JaCoCo reports, threshold enforcement

**Verification Steps:**
1. **Quality Build**: Execute quality build for rapid feedback
2. **Complete Test Suite**: Execute verification build for comprehensive validation
3. **Coverage Verification**: Execute coverage build for detailed metrics
4. **Final Commit**: Consolidate if needed, update module status

**Important Notes:**
* No `-Pverification` profile exists - use standard `verify` goal
* Use module-specific execution with `-pl <module>` for faster builds
* Combine profiles as needed: `-Ppre-commit,coverage`

== Common Improvements

=== Test Simplification Process
* **Apply AI artifact removal** per xref:../testing/quality-standards.adoc#ai-generated-code-detection[Quality Standards]
* **Remove non-sensible tests** per quality standards criteria
* **Refactor complex test logic** to follow AAA pattern per xref:../testing/core-standards.adoc[Core Standards]
* **Extract repeated test data** to TypeGenerator implementations
* **Convert similar tests** to parameterized tests using @GeneratorsSource
* **Fix compliance violations** per xref:../testing/quality-standards.adoc#sonarqube-compliance[SonarQube Standards]

=== Framework Migration Process

**Migration Steps:**
1. **Identify Violations**: Scan for manual data creation, hardcoded values, non-CUI frameworks
2. **Apply Standards**: Follow patterns per xref:../testing/cui-test-generator-guide.adoc[CUI Test Generator Guide]
3. **Verify Compliance**: Check against xref:../testing/quality-standards.adoc#cui-testing-utilities[CUI Testing Standards]
4. **Test Execution**: Ensure all tests pass after migration

=== Value Object Testing Process

**Apply ShouldHandleObjectContracts<T> when:**
* Class implements custom equals()/hashCode() methods
* Class represents domain data with value semantics
* Class is used in collections or as map keys
* Class participates in caching or persistence operations

**Do NOT apply to:**
* Enums (already have proper equals/hashCode from Java)
* Utility classes with only static methods
* Infrastructure classes (parsers, validators, builders)
* Classes that don't represent business value objects
* Builder pattern classes (test the built object instead)

**Implementation Steps:**
1. **Identify Value Objects**: Locate classes requiring contract testing using above criteria
2. **Apply Standards**: Follow patterns per xref:../testing/cui-test-generator-guide.adoc[CUI Test Generator Guide]
3. **Verify Coverage**: Ensure equals(), hashCode(), toString(), and Serializable contracts are tested
4. **Generator Integration**: Use cui-test-generator for all test data creation

**Implementation Pattern:**
[source,java]
----
@EnableGeneratorController
class AccessTokenContentTest implements ShouldHandleObjectContracts<AccessTokenContent> {
    
    @ParameterizedTest
    @TestTokenSource(value = TokenType.ACCESS_TOKEN, count = 2)
    @DisplayName("Should handle business logic correctly")
    void shouldHandleBusinessLogic(TestTokenHolder tokenHolder) {
        // Business logic tests here
        // Contract testing is automatically applied via interface
    }
}
----

**Common Mistakes to Avoid:**
* Applying contracts to enums (unnecessary)
* Testing infrastructure classes as value objects
* Mixing business logic tests with contract-only test classes

=== Structure Optimization
* Group related tests in inner classes
* Extract common setup to base classes  
* Simplify test resource management
* Improve test readability

For complete quality verification, see xref:task-completion-standards.adoc[Task Completion Standards].
